---
description: All coding
alwaysApply: false
---
# DRY Principle

1. Tree-Based Code Reuse Enforcement

All contributors must perform a comprehensive tree search before implementing any new functionality.

    This search must include filename, function names, and keywords relevant to the intended logic.

    If an existing implementation is found, it must be reused via import.

    Duplicate logic is strictly prohibited and will be flagged for removal or consolidation.

Policy Enforcement:
If an implementation is found to replicate existing logic, the commit will be rejected until the code is refactored to comply with DRY (Don't Repeat Yourself) principles.
2. File Size & Responsibility Constraints

All new code must adhere to strict file modularity:

    Each file must encapsulate a single responsibility only.

    Files must be structured to ensure logical and functional separation.

    A soft maximum of 100 lines per file must be followed. Exceeding this limit requires explicit justification and prior approval.

Policy Enforcement:

    Files exceeding 100 lines will be flagged.

    Multiple responsibilities in one file will result in a rejection until separation is applied.

3. Mandatory Module Splitting

All utility functions, helpers, constants, schemas, data models, etc., must be split into clearly named, purpose-specific modules.

    No "miscellaneous" or overly generic filenames are permitted (e.g., misc.js, helpers2.go, utilFinal.ts are disallowed).

    Modules must be named according to their exact role or purpose.

4. Explicit Imports Required

When a module depends on another, it must import only what it needs explicitly.

    No logic duplication is allowed across files.

    Indirect referencing or implicit duplication will be considered a violation.
