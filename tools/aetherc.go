package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

type CFunction struct {
	Name       string
	ReturnType string
	Parameters []CParameter
	Header     string
	Library    string
}

type CParameter struct {
	Name string
	Type string
}

type CBinding struct {
	Functions []CFunction
	Headers   []string
	Libraries []string
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: aetherc <command> [options]")
		fmt.Println("Commands:")
		fmt.Println("  generate <output.ae>  Generate Aether bindings from C header")
		fmt.Println("  list                  List available C functions")
		fmt.Println("  help                  Show this help")
		return
	}

	command := os.Args[1]
	switch command {
	case "generate":
		if len(os.Args) < 3 {
			fmt.Println("Usage: aetherc generate <output.ae>")
			return
		}
		generateBindings(os.Args[2])
	case "list":
		listFunctions()
	case "help":
		fmt.Println("aetherc - C binding tool for Aether")
		fmt.Println("Generate Aether bindings for C functions")
	default:
		fmt.Printf("Unknown command: %s\n", command)
		fmt.Println("Use 'aetherc help' for usage")
	}
}

func generateBindings(outputFile string) {
	binding := CBinding{
		Functions: getStandardCFunctions(),
		Headers:   []string{"stdio.h", "stdlib.h", "string.h", "math.h"},
		Libraries: []string{"c", "m"},
	}

	// Generate the Aether binding file
	tmpl := template.Must(template.New("binding").Parse(bindingTemplate))

	file, err := os.Create(outputFile)
	if err != nil {
		fmt.Printf("Error creating file: %v\n", err)
		return
	}
	defer file.Close()

	if err := tmpl.Execute(file, binding); err != nil {
		fmt.Printf("Error generating bindings: %v\n", err)
		return
	}

	fmt.Printf("Generated C bindings: %s\n", outputFile)
}

func listFunctions() {
	functions := getStandardCFunctions()
	fmt.Println("Available C functions:")
	for _, fn := range functions {
		fmt.Printf("  %s(%s) -> %s\n", fn.Name, formatParameters(fn.Parameters), fn.ReturnType)
	}
}

func getStandardCFunctions() []CFunction {
	return []CFunction{
		{
			Name:       "printf",
			ReturnType: "int",
			Parameters: []CParameter{{Name: "format", Type: "string"}, {Name: "...", Type: "variadic"}},
			Header:     "stdio.h",
			Library:    "c",
		},
		{
			Name:       "puts",
			ReturnType: "int",
			Parameters: []CParameter{{Name: "str", Type: "string"}},
			Header:     "stdio.h",
			Library:    "c",
		},
		{
			Name:       "malloc",
			ReturnType: "pointer",
			Parameters: []CParameter{{Name: "size", Type: "int"}},
			Header:     "stdlib.h",
			Library:    "c",
		},
		{
			Name:       "free",
			ReturnType: "void",
			Parameters: []CParameter{{Name: "ptr", Type: "pointer"}},
			Header:     "stdlib.h",
			Library:    "c",
		},
		{
			Name:       "strlen",
			ReturnType: "int",
			Parameters: []CParameter{{Name: "str", Type: "string"}},
			Header:     "string.h",
			Library:    "c",
		},
		{
			Name:       "sin",
			ReturnType: "double",
			Parameters: []CParameter{{Name: "x", Type: "double"}},
			Header:     "math.h",
			Library:    "m",
		},
		{
			Name:       "cos",
			ReturnType: "double",
			Parameters: []CParameter{{Name: "x", Type: "double"}},
			Header:     "math.h",
			Library:    "m",
		},
		{
			Name:       "sqrt",
			ReturnType: "double",
			Parameters: []CParameter{{Name: "x", Type: "double"}},
			Header:     "math.h",
			Library:    "m",
		},
	}
}

func formatParameters(params []CParameter) string {
	if len(params) == 0 {
		return ""
	}

	parts := make([]string, len(params))
	for i, param := range params {
		parts[i] = fmt.Sprintf("%s %s", param.Type, param.Name)
	}
	return strings.Join(parts, ", ")
}

const bindingTemplate = `# Aether C Bindings
# Generated by aetherc

import "c"

# C function bindings
{{range .Functions}}
{{.Name}} = c.bind("{{.Name}}", "{{.ReturnType}}"{{range .Parameters}}, "{{.Type}}"{{end}})
{{end}}

# C headers included
{{range .Headers}}
#include <{{.}}>
{{end}}

# C libraries linked
{{range .Libraries}}
#link -l{{.}}
{{end}}
`
