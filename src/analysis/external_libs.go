package analysis

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type ExternalLibrary struct {
	Name         string
	Path         string
	Type         string // "shared", "static", "system"
	Symbols      []string
	Functions    []LibraryFunction
	Dependencies []string
	Version      string
	Description  string
}

type LibraryFunction struct {
	Name       string
	Signature  string
	ReturnType string
	Parameters []string
}

type LibraryBinding struct {
	LibraryName string
	Functions   map[string]LibraryFunction
	Symbols     map[string]string
}

func AnalyzeExternalLibrary(libPath string) (*ExternalLibrary, error) {
	lib := &ExternalLibrary{
		Path: libPath,
		Name: filepath.Base(libPath),
	}

	// Determine library type
	if strings.HasSuffix(libPath, ".so") || strings.HasSuffix(libPath, ".dll") || strings.HasSuffix(libPath, ".dylib") {
		lib.Type = "shared"
	} else if strings.HasSuffix(libPath, ".a") || strings.HasSuffix(libPath, ".lib") {
		lib.Type = "static"
	} else {
		lib.Type = "system"
	}

	// Extract symbols using nm
	if err := extractSymbols(lib); err != nil {
		return nil, fmt.Errorf("failed to extract symbols: %v", err)
	}

	// Extract functions using objdump
	if err := extractFunctions(lib); err != nil {
		return nil, fmt.Errorf("failed to extract functions: %v", err)
	}

	// Extract dependencies using ldd (for shared libraries)
	if lib.Type == "shared" {
		if err := extractDependencies(lib); err != nil {
			return nil, fmt.Errorf("failed to extract dependencies: %v", err)
		}
	}

	return lib, nil
}

func extractSymbols(lib *ExternalLibrary) error {
	cmd := exec.Command("nm", "-D", lib.Path)
	output, err := cmd.Output()
	if err != nil {
		return err
	}

	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		// Parse nm output format: address type symbol
		parts := strings.Fields(line)
		if len(parts) >= 3 {
			symbolType := parts[1]
			symbolName := parts[2]

			// Only include exported symbols (T, D, B)
			if strings.Contains("TDB", symbolType) {
				lib.Symbols = append(lib.Symbols, symbolName)
			}
		}
	}

	return nil
}

func extractFunctions(lib *ExternalLibrary) error {
	cmd := exec.Command("objdump", "-T", lib.Path)
	output, err := cmd.Output()
	if err != nil {
		return err
	}

	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "DYNAMIC SYMBOL TABLE") {
			continue
		}

		// Parse objdump output format
		parts := strings.Fields(line)
		if len(parts) >= 6 {
			symbolType := parts[5]
			symbolName := parts[6]

			// Only include functions (DF, DO, etc.)
			if strings.Contains(symbolType, "DF") || strings.Contains(symbolType, "DO") {
				function := LibraryFunction{
					Name: symbolName,
				}
				lib.Functions = append(lib.Functions, function)
			}
		}
	}

	return nil
}

func extractDependencies(lib *ExternalLibrary) error {
	cmd := exec.Command("ldd", lib.Path)
	output, err := cmd.Output()
	if err != nil {
		return err
	}

	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.Contains(line, "not a dynamic executable") {
			continue
		}

		// Parse ldd output format: lib => path
		if strings.Contains(line, "=>") {
			parts := strings.Split(line, "=>")
			if len(parts) >= 2 {
				libName := strings.TrimSpace(parts[0])
				lib.Dependencies = append(lib.Dependencies, libName)
			}
		}
	}

	return nil
}

func GenerateLibraryBinding(lib *ExternalLibrary) (*LibraryBinding, error) {
	binding := &LibraryBinding{
		LibraryName: lib.Name,
		Functions:   make(map[string]LibraryFunction),
		Symbols:     make(map[string]string),
	}

	// Map functions
	for _, function := range lib.Functions {
		binding.Functions[function.Name] = function
	}

	// Map symbols
	for _, symbol := range lib.Symbols {
		binding.Symbols[symbol] = "unknown"
	}

	return binding, nil
}

func GenerateAetherBinding(binding *LibraryBinding) string {
	var code strings.Builder

	code.WriteString(fmt.Sprintf("// Auto-generated binding for %s\n", binding.LibraryName))
	code.WriteString("// Generated by Aether compiler\n\n")

	// Add library import
	code.WriteString(fmt.Sprintf("import \"%s\" as %s\n\n", binding.LibraryName, strings.ToLower(binding.LibraryName)))

	// Generate function bindings
	for name, _ := range binding.Functions {
		code.WriteString(fmt.Sprintf("func %s {\n", name))
		code.WriteString(fmt.Sprintf("  return %s.%s()\n", strings.ToLower(binding.LibraryName), name))
		code.WriteString("}\n\n")
	}

	// Generate symbol bindings
	for name, _ := range binding.Symbols {
		code.WriteString(fmt.Sprintf("const %s = %s.%s\n", name, strings.ToLower(binding.LibraryName), name))
	}

	return code.String()
}

func FindLibrary(libName string) (string, error) {
	// Search in common library paths
	searchPaths := []string{
		"/usr/lib",
		"/usr/local/lib",
		"/lib",
		"/lib64",
		"/usr/lib64",
		"/usr/local/lib64",
	}

	// Try different library extensions
	extensions := []string{".so", ".dll", ".dylib", ".a", ".lib"}

	for _, path := range searchPaths {
		for _, ext := range extensions {
			fullPath := filepath.Join(path, "lib"+libName+ext)
			if _, err := os.Stat(fullPath); err == nil {
				return fullPath, nil
			}
		}
	}

	return "", fmt.Errorf("library %s not found", libName)
}

func ValidateLibraryBinding(binding *LibraryBinding) []string {
	var errors []string

	// Check if library exists
	if _, err := FindLibrary(binding.LibraryName); err != nil {
		errors = append(errors, fmt.Sprintf("Library %s not found: %v", binding.LibraryName, err))
	}

	// Check for duplicate function names
	seen := make(map[string]bool)
	for name, _ := range binding.Functions {
		if seen[name] {
			errors = append(errors, fmt.Sprintf("Duplicate function name: %s", name))
		}
		seen[name] = true
	}

	return errors
}
